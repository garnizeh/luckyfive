// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: results.sql

package results

import (
	"context"
	"database/sql"
)

const countDraws = `-- name: CountDraws :one
SELECT COUNT(*) FROM draws
`

func (q *Queries) CountDraws(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDraws)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDrawsBetweenDates = `-- name: CountDrawsBetweenDates :one
SELECT COUNT(*) FROM draws
WHERE draw_date BETWEEN ? AND ?
`

type CountDrawsBetweenDatesParams struct {
	FromDrawDate string `json:"from_draw_date"`
	ToDrawDate   string `json:"to_draw_date"`
}

func (q *Queries) CountDrawsBetweenDates(ctx context.Context, arg CountDrawsBetweenDatesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDrawsBetweenDates, arg.FromDrawDate, arg.ToDrawDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteDraw = `-- name: DeleteDraw :exec
DELETE FROM draws WHERE contest = ?
`

func (q *Queries) DeleteDraw(ctx context.Context, contest int64) error {
	_, err := q.db.ExecContext(ctx, deleteDraw, contest)
	return err
}

const getContestRange = `-- name: GetContestRange :one
SELECT MIN(contest) as min_contest, MAX(contest) as max_contest
FROM draws
`

type GetContestRangeRow struct {
	MinContest interface{} `json:"min_contest"`
	MaxContest interface{} `json:"max_contest"`
}

func (q *Queries) GetContestRange(ctx context.Context) (GetContestRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getContestRange)
	var i GetContestRangeRow
	err := row.Scan(&i.MinContest, &i.MaxContest)
	return i, err
}

const getDraw = `-- name: GetDraw :one

SELECT contest, draw_date, bola1, bola2, bola3, bola4, bola5, source, imported_at, raw_row FROM draws
WHERE contest = ?
LIMIT 1
`

// schema: migrations/001_create_results.sql
func (q *Queries) GetDraw(ctx context.Context, contest int64) (Draw, error) {
	row := q.db.QueryRowContext(ctx, getDraw, contest)
	var i Draw
	err := row.Scan(
		&i.Contest,
		&i.DrawDate,
		&i.Bola1,
		&i.Bola2,
		&i.Bola3,
		&i.Bola4,
		&i.Bola5,
		&i.Source,
		&i.ImportedAt,
		&i.RawRow,
	)
	return i, err
}

const getDrawByDate = `-- name: GetDrawByDate :many
SELECT contest, draw_date, bola1, bola2, bola3, bola4, bola5, source, imported_at, raw_row FROM draws
WHERE draw_date = ?
ORDER BY contest DESC
`

func (q *Queries) GetDrawByDate(ctx context.Context, drawDate string) ([]Draw, error) {
	rows, err := q.db.QueryContext(ctx, getDrawByDate, drawDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Draw
	for rows.Next() {
		var i Draw
		if err := rows.Scan(
			&i.Contest,
			&i.DrawDate,
			&i.Bola1,
			&i.Bola2,
			&i.Bola3,
			&i.Bola4,
			&i.Bola5,
			&i.Source,
			&i.ImportedAt,
			&i.RawRow,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImportHistory = `-- name: GetImportHistory :many
SELECT id, filename, imported_at, rows_inserted, rows_skipped, rows_errors, source_hash, metadata FROM import_history
ORDER BY imported_at DESC
LIMIT ? OFFSET ?
`

type GetImportHistoryParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) GetImportHistory(ctx context.Context, arg GetImportHistoryParams) ([]ImportHistory, error) {
	rows, err := q.db.QueryContext(ctx, getImportHistory, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ImportHistory
	for rows.Next() {
		var i ImportHistory
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.ImportedAt,
			&i.RowsInserted,
			&i.RowsSkipped,
			&i.RowsErrors,
			&i.SourceHash,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDraw = `-- name: InsertDraw :exec
INSERT INTO draws (
  contest, draw_date, bola1, bola2, bola3, bola4, bola5, source, raw_row
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertDrawParams struct {
	Contest  int64          `json:"contest"`
	DrawDate string         `json:"draw_date"`
	Bola1    int64          `json:"bola1"`
	Bola2    int64          `json:"bola2"`
	Bola3    int64          `json:"bola3"`
	Bola4    int64          `json:"bola4"`
	Bola5    int64          `json:"bola5"`
	Source   sql.NullString `json:"source"`
	RawRow   sql.NullString `json:"raw_row"`
}

func (q *Queries) InsertDraw(ctx context.Context, arg InsertDrawParams) error {
	_, err := q.db.ExecContext(ctx, insertDraw,
		arg.Contest,
		arg.DrawDate,
		arg.Bola1,
		arg.Bola2,
		arg.Bola3,
		arg.Bola4,
		arg.Bola5,
		arg.Source,
		arg.RawRow,
	)
	return err
}

const insertImportHistory = `-- name: InsertImportHistory :one
INSERT INTO import_history (
  filename, rows_inserted, rows_skipped, rows_errors, source_hash, metadata
) VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, filename, imported_at, rows_inserted, rows_skipped, rows_errors, source_hash, metadata
`

type InsertImportHistoryParams struct {
	Filename     string         `json:"filename"`
	RowsInserted int64          `json:"rows_inserted"`
	RowsSkipped  int64          `json:"rows_skipped"`
	RowsErrors   int64          `json:"rows_errors"`
	SourceHash   sql.NullString `json:"source_hash"`
	Metadata     sql.NullString `json:"metadata"`
}

func (q *Queries) InsertImportHistory(ctx context.Context, arg InsertImportHistoryParams) (ImportHistory, error) {
	row := q.db.QueryRowContext(ctx, insertImportHistory,
		arg.Filename,
		arg.RowsInserted,
		arg.RowsSkipped,
		arg.RowsErrors,
		arg.SourceHash,
		arg.Metadata,
	)
	var i ImportHistory
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.ImportedAt,
		&i.RowsInserted,
		&i.RowsSkipped,
		&i.RowsErrors,
		&i.SourceHash,
		&i.Metadata,
	)
	return i, err
}

const listDraws = `-- name: ListDraws :many
SELECT contest, draw_date, bola1, bola2, bola3, bola4, bola5, source, imported_at, raw_row FROM draws
ORDER BY contest DESC
LIMIT ? OFFSET ?
`

type ListDrawsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListDraws(ctx context.Context, arg ListDrawsParams) ([]Draw, error) {
	rows, err := q.db.QueryContext(ctx, listDraws, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Draw
	for rows.Next() {
		var i Draw
		if err := rows.Scan(
			&i.Contest,
			&i.DrawDate,
			&i.Bola1,
			&i.Bola2,
			&i.Bola3,
			&i.Bola4,
			&i.Bola5,
			&i.Source,
			&i.ImportedAt,
			&i.RawRow,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDrawsByBall = `-- name: ListDrawsByBall :many
SELECT contest, draw_date, bola1, bola2, bola3, bola4, bola5, source, imported_at, raw_row FROM draws
WHERE bola1 = ? OR bola2 = ? OR bola3 = ? OR bola4 = ? OR bola5 = ?
ORDER BY contest DESC
LIMIT ? OFFSET ?
`

type ListDrawsByBallParams struct {
	Bola1  int64 `json:"bola1"`
	Bola2  int64 `json:"bola2"`
	Bola3  int64 `json:"bola3"`
	Bola4  int64 `json:"bola4"`
	Bola5  int64 `json:"bola5"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListDrawsByBall(ctx context.Context, arg ListDrawsByBallParams) ([]Draw, error) {
	rows, err := q.db.QueryContext(ctx, listDrawsByBall,
		arg.Bola1,
		arg.Bola2,
		arg.Bola3,
		arg.Bola4,
		arg.Bola5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Draw
	for rows.Next() {
		var i Draw
		if err := rows.Scan(
			&i.Contest,
			&i.DrawDate,
			&i.Bola1,
			&i.Bola2,
			&i.Bola3,
			&i.Bola4,
			&i.Bola5,
			&i.Source,
			&i.ImportedAt,
			&i.RawRow,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDrawsByContestRange = `-- name: ListDrawsByContestRange :many
SELECT contest, draw_date, bola1, bola2, bola3, bola4, bola5, source, imported_at, raw_row FROM draws
WHERE contest BETWEEN ? AND ?
ORDER BY contest ASC
`

type ListDrawsByContestRangeParams struct {
	FromContest int64 `json:"from_contest"`
	ToContest   int64 `json:"to_contest"`
}

func (q *Queries) ListDrawsByContestRange(ctx context.Context, arg ListDrawsByContestRangeParams) ([]Draw, error) {
	rows, err := q.db.QueryContext(ctx, listDrawsByContestRange, arg.FromContest, arg.ToContest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Draw
	for rows.Next() {
		var i Draw
		if err := rows.Scan(
			&i.Contest,
			&i.DrawDate,
			&i.Bola1,
			&i.Bola2,
			&i.Bola3,
			&i.Bola4,
			&i.Bola5,
			&i.Source,
			&i.ImportedAt,
			&i.RawRow,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDrawsByDateRange = `-- name: ListDrawsByDateRange :many
SELECT contest, draw_date, bola1, bola2, bola3, bola4, bola5, source, imported_at, raw_row FROM draws
WHERE draw_date BETWEEN ? AND ?
ORDER BY contest DESC
LIMIT ? OFFSET ?
`

type ListDrawsByDateRangeParams struct {
	FromDrawDate string `json:"from_draw_date"`
	ToDrawDate   string `json:"to_draw_date"`
	Limit        int64  `json:"limit"`
	Offset       int64  `json:"offset"`
}

func (q *Queries) ListDrawsByDateRange(ctx context.Context, arg ListDrawsByDateRangeParams) ([]Draw, error) {
	rows, err := q.db.QueryContext(ctx, listDrawsByDateRange,
		arg.FromDrawDate,
		arg.ToDrawDate,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Draw
	for rows.Next() {
		var i Draw
		if err := rows.Scan(
			&i.Contest,
			&i.DrawDate,
			&i.Bola1,
			&i.Bola2,
			&i.Bola3,
			&i.Bola4,
			&i.Bola5,
			&i.Source,
			&i.ImportedAt,
			&i.RawRow,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertDraw = `-- name: UpsertDraw :exec
INSERT INTO draws (
  contest, draw_date, bola1, bola2, bola3, bola4, bola5, source, raw_row
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(contest) DO UPDATE SET
  draw_date = excluded.draw_date,
  bola1 = excluded.bola1,
  bola2 = excluded.bola2,
  bola3 = excluded.bola3,
  bola4 = excluded.bola4,
  bola5 = excluded.bola5,
  source = excluded.source,
  raw_row = excluded.raw_row,
  imported_at = CURRENT_TIMESTAMP
`

type UpsertDrawParams struct {
	Contest  int64          `json:"contest"`
	DrawDate string         `json:"draw_date"`
	Bola1    int64          `json:"bola1"`
	Bola2    int64          `json:"bola2"`
	Bola3    int64          `json:"bola3"`
	Bola4    int64          `json:"bola4"`
	Bola5    int64          `json:"bola5"`
	Source   sql.NullString `json:"source"`
	RawRow   sql.NullString `json:"raw_row"`
}

func (q *Queries) UpsertDraw(ctx context.Context, arg UpsertDrawParams) error {
	_, err := q.db.ExecContext(ctx, upsertDraw,
		arg.Contest,
		arg.DrawDate,
		arg.Bola1,
		arg.Bola2,
		arg.Bola3,
		arg.Bola4,
		arg.Bola5,
		arg.Source,
		arg.RawRow,
	)
	return err
}
