// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: simulations.sql

package simulations

import (
	"context"
	"database/sql"
)

const cancelSimulation = `-- name: CancelSimulation :exec
UPDATE simulations
SET status = 'cancelled',
    finished_at = ?
WHERE id = ? AND status IN ('pending', 'running')
`

type CancelSimulationParams struct {
	FinishedAt sql.NullString `json:"finished_at"`
	ID         int64          `json:"id"`
}

func (q *Queries) CancelSimulation(ctx context.Context, arg CancelSimulationParams) error {
	_, err := q.db.ExecContext(ctx, cancelSimulation, arg.FinishedAt, arg.ID)
	return err
}

const claimPendingSimulation = `-- name: ClaimPendingSimulation :one
UPDATE simulations
SET status = 'running',
    started_at = ?,
    worker_id = ?
WHERE id = (
    SELECT id FROM simulations
    WHERE status = 'pending'
    ORDER BY created_at ASC
    LIMIT 1
)
RETURNING id, created_at, started_at, finished_at, status, recipe_name, recipe_json, mode, start_contest, end_contest, worker_id, run_duration_ms, summary_json, output_blob, output_name, log_blob, error_message, error_stack, created_by
`

type ClaimPendingSimulationParams struct {
	StartedAt sql.NullString `json:"started_at"`
	WorkerID  sql.NullString `json:"worker_id"`
}

func (q *Queries) ClaimPendingSimulation(ctx context.Context, arg ClaimPendingSimulationParams) (Simulation, error) {
	row := q.db.QueryRowContext(ctx, claimPendingSimulation, arg.StartedAt, arg.WorkerID)
	var i Simulation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
		&i.RecipeName,
		&i.RecipeJson,
		&i.Mode,
		&i.StartContest,
		&i.EndContest,
		&i.WorkerID,
		&i.RunDurationMs,
		&i.SummaryJson,
		&i.OutputBlob,
		&i.OutputName,
		&i.LogBlob,
		&i.ErrorMessage,
		&i.ErrorStack,
		&i.CreatedBy,
	)
	return i, err
}

const completeSimulation = `-- name: CompleteSimulation :exec
UPDATE simulations
SET status = 'completed',
    finished_at = ?,
    run_duration_ms = ?,
    summary_json = ?,
    output_blob = ?,
    output_name = ?
WHERE id = ?
`

type CompleteSimulationParams struct {
	FinishedAt    sql.NullString `json:"finished_at"`
	RunDurationMs sql.NullInt64  `json:"run_duration_ms"`
	SummaryJson   sql.NullString `json:"summary_json"`
	OutputBlob    []byte         `json:"output_blob"`
	OutputName    sql.NullString `json:"output_name"`
	ID            int64          `json:"id"`
}

func (q *Queries) CompleteSimulation(ctx context.Context, arg CompleteSimulationParams) error {
	_, err := q.db.ExecContext(ctx, completeSimulation,
		arg.FinishedAt,
		arg.RunDurationMs,
		arg.SummaryJson,
		arg.OutputBlob,
		arg.OutputName,
		arg.ID,
	)
	return err
}

const countSimulationsByStatus = `-- name: CountSimulationsByStatus :one
SELECT COUNT(*) FROM simulations
WHERE status = ?
`

func (q *Queries) CountSimulationsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSimulationsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSimulation = `-- name: CreateSimulation :one
INSERT INTO simulations (
    recipe_name, recipe_json, mode, start_contest, end_contest, created_by
) VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, created_at, started_at, finished_at, status, recipe_name, recipe_json, mode, start_contest, end_contest, worker_id, run_duration_ms, summary_json, output_blob, output_name, log_blob, error_message, error_stack, created_by
`

type CreateSimulationParams struct {
	RecipeName   sql.NullString `json:"recipe_name"`
	RecipeJson   string         `json:"recipe_json"`
	Mode         string         `json:"mode"`
	StartContest int64          `json:"start_contest"`
	EndContest   int64          `json:"end_contest"`
	CreatedBy    sql.NullString `json:"created_by"`
}

func (q *Queries) CreateSimulation(ctx context.Context, arg CreateSimulationParams) (Simulation, error) {
	row := q.db.QueryRowContext(ctx, createSimulation,
		arg.RecipeName,
		arg.RecipeJson,
		arg.Mode,
		arg.StartContest,
		arg.EndContest,
		arg.CreatedBy,
	)
	var i Simulation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
		&i.RecipeName,
		&i.RecipeJson,
		&i.Mode,
		&i.StartContest,
		&i.EndContest,
		&i.WorkerID,
		&i.RunDurationMs,
		&i.SummaryJson,
		&i.OutputBlob,
		&i.OutputName,
		&i.LogBlob,
		&i.ErrorMessage,
		&i.ErrorStack,
		&i.CreatedBy,
	)
	return i, err
}

const failSimulation = `-- name: FailSimulation :exec
UPDATE simulations
SET status = 'failed',
    finished_at = ?,
    error_message = ?,
    error_stack = ?
WHERE id = ?
`

type FailSimulationParams struct {
	FinishedAt   sql.NullString `json:"finished_at"`
	ErrorMessage sql.NullString `json:"error_message"`
	ErrorStack   sql.NullString `json:"error_stack"`
	ID           int64          `json:"id"`
}

func (q *Queries) FailSimulation(ctx context.Context, arg FailSimulationParams) error {
	_, err := q.db.ExecContext(ctx, failSimulation,
		arg.FinishedAt,
		arg.ErrorMessage,
		arg.ErrorStack,
		arg.ID,
	)
	return err
}

const getContestResults = `-- name: GetContestResults :many
SELECT id, simulation_id, contest, actual_numbers, best_hits, best_prediction_index, best_prediction_numbers, predictions_json, processed_at
FROM simulation_contest_results
WHERE simulation_id = ?
ORDER BY contest ASC
LIMIT ? OFFSET ?
`

type GetContestResultsParams struct {
	SimulationID int64 `json:"simulation_id"`
	Limit        int64 `json:"limit"`
	Offset       int64 `json:"offset"`
}

func (q *Queries) GetContestResults(ctx context.Context, arg GetContestResultsParams) ([]SimulationContestResult, error) {
	rows, err := q.db.QueryContext(ctx, getContestResults, arg.SimulationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SimulationContestResult
	for rows.Next() {
		var i SimulationContestResult
		if err := rows.Scan(
			&i.ID,
			&i.SimulationID,
			&i.Contest,
			&i.ActualNumbers,
			&i.BestHits,
			&i.BestPredictionIndex,
			&i.BestPredictionNumbers,
			&i.PredictionsJson,
			&i.ProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContestResultsByMinHits = `-- name: GetContestResultsByMinHits :many
SELECT id, simulation_id, contest, actual_numbers, best_hits, best_prediction_index, best_prediction_numbers, predictions_json, processed_at
FROM simulation_contest_results
WHERE simulation_id = ? AND best_hits >= ?
ORDER BY best_hits DESC, contest ASC
LIMIT ? OFFSET ?
`

type GetContestResultsByMinHitsParams struct {
	SimulationID int64 `json:"simulation_id"`
	BestHits     int64 `json:"best_hits"`
	Limit        int64 `json:"limit"`
	Offset       int64 `json:"offset"`
}

func (q *Queries) GetContestResultsByMinHits(ctx context.Context, arg GetContestResultsByMinHitsParams) ([]SimulationContestResult, error) {
	rows, err := q.db.QueryContext(ctx, getContestResultsByMinHits,
		arg.SimulationID,
		arg.BestHits,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SimulationContestResult
	for rows.Next() {
		var i SimulationContestResult
		if err := rows.Scan(
			&i.ID,
			&i.SimulationID,
			&i.Contest,
			&i.ActualNumbers,
			&i.BestHits,
			&i.BestPredictionIndex,
			&i.BestPredictionNumbers,
			&i.PredictionsJson,
			&i.ProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimulation = `-- name: GetSimulation :one
SELECT id, created_at, started_at, finished_at, status, recipe_name, recipe_json, mode, start_contest, end_contest, worker_id, run_duration_ms, summary_json, output_blob, output_name, log_blob, error_message, error_stack, created_by FROM simulations
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetSimulation(ctx context.Context, id int64) (Simulation, error) {
	row := q.db.QueryRowContext(ctx, getSimulation, id)
	var i Simulation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
		&i.RecipeName,
		&i.RecipeJson,
		&i.Mode,
		&i.StartContest,
		&i.EndContest,
		&i.WorkerID,
		&i.RunDurationMs,
		&i.SummaryJson,
		&i.OutputBlob,
		&i.OutputName,
		&i.LogBlob,
		&i.ErrorMessage,
		&i.ErrorStack,
		&i.CreatedBy,
	)
	return i, err
}

const insertContestResult = `-- name: InsertContestResult :exec
INSERT INTO simulation_contest_results (
    simulation_id, contest, actual_numbers, best_hits,
    best_prediction_index, best_prediction_numbers, predictions_json
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type InsertContestResultParams struct {
	SimulationID          int64          `json:"simulation_id"`
	Contest               int64          `json:"contest"`
	ActualNumbers         string         `json:"actual_numbers"`
	BestHits              int64          `json:"best_hits"`
	BestPredictionIndex   sql.NullInt64  `json:"best_prediction_index"`
	BestPredictionNumbers sql.NullString `json:"best_prediction_numbers"`
	PredictionsJson       string         `json:"predictions_json"`
}

func (q *Queries) InsertContestResult(ctx context.Context, arg InsertContestResultParams) error {
	_, err := q.db.ExecContext(ctx, insertContestResult,
		arg.SimulationID,
		arg.Contest,
		arg.ActualNumbers,
		arg.BestHits,
		arg.BestPredictionIndex,
		arg.BestPredictionNumbers,
		arg.PredictionsJson,
	)
	return err
}

const listSimulations = `-- name: ListSimulations :many
SELECT id, created_at, started_at, finished_at, status, recipe_name, recipe_json, mode, start_contest, end_contest, worker_id, run_duration_ms, summary_json, output_blob, output_name, log_blob, error_message, error_stack, created_by FROM simulations
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListSimulationsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListSimulations(ctx context.Context, arg ListSimulationsParams) ([]Simulation, error) {
	rows, err := q.db.QueryContext(ctx, listSimulations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Simulation
	for rows.Next() {
		var i Simulation
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Status,
			&i.RecipeName,
			&i.RecipeJson,
			&i.Mode,
			&i.StartContest,
			&i.EndContest,
			&i.WorkerID,
			&i.RunDurationMs,
			&i.SummaryJson,
			&i.OutputBlob,
			&i.OutputName,
			&i.LogBlob,
			&i.ErrorMessage,
			&i.ErrorStack,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSimulationsByStatus = `-- name: ListSimulationsByStatus :many
SELECT id, created_at, started_at, finished_at, status, recipe_name, recipe_json, mode, start_contest, end_contest, worker_id, run_duration_ms, summary_json, output_blob, output_name, log_blob, error_message, error_stack, created_by FROM simulations
WHERE status = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListSimulationsByStatusParams struct {
	Status string `json:"status"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) ListSimulationsByStatus(ctx context.Context, arg ListSimulationsByStatusParams) ([]Simulation, error) {
	rows, err := q.db.QueryContext(ctx, listSimulationsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Simulation
	for rows.Next() {
		var i Simulation
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Status,
			&i.RecipeName,
			&i.RecipeJson,
			&i.Mode,
			&i.StartContest,
			&i.EndContest,
			&i.WorkerID,
			&i.RunDurationMs,
			&i.SummaryJson,
			&i.OutputBlob,
			&i.OutputName,
			&i.LogBlob,
			&i.ErrorMessage,
			&i.ErrorStack,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSimulationStatus = `-- name: UpdateSimulationStatus :exec
UPDATE simulations
SET status = ?, started_at = ?, worker_id = ?
WHERE id = ? AND status = 'pending'
`

type UpdateSimulationStatusParams struct {
	Status    string         `json:"status"`
	StartedAt sql.NullString `json:"started_at"`
	WorkerID  sql.NullString `json:"worker_id"`
	ID        int64          `json:"id"`
}

func (q *Queries) UpdateSimulationStatus(ctx context.Context, arg UpdateSimulationStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateSimulationStatus,
		arg.Status,
		arg.StartedAt,
		arg.WorkerID,
		arg.ID,
	)
	return err
}
